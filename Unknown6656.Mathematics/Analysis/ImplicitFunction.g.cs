
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED 2024-07-28 23:18:37.957581              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System;

using Unknown6656.Mathematics.LinearAlgebra;

namespace Unknown6656.Mathematics.Analysis;


public partial class ImplicitScalarFunction2D
    : ImplicitFunction<Vector2>
{
    public bool this[Scalar x0, Scalar x1] => Evaluate(x0, x1);

    public bool this[Scalar x0, Scalar x1, Scalar tolerance] => Evaluate(x0, x1, tolerance);


    public ImplicitScalarFunction2D(ImplicitFunction<Vector2> function)
        : this(function.ExplicitFunction, function.ComparisonOperator)
    {
    }

    public ImplicitScalarFunction2D(Function<Vector2, Scalar> function)
        : this(function, ComparisonOperator.EqualTo)
    {
    }

    public ImplicitScalarFunction2D(Func<Vector2, Scalar> function)
        : this(new Function<Vector2, Scalar>(function))
    {
    }

    public ImplicitScalarFunction2D(Function<Vector2, Scalar> function, ComparisonOperator comparison)
        : base(function, comparison)
    {
    }

    public ImplicitScalarFunction2D(Func<Vector2, Scalar> function, ComparisonOperator comparison)
        : this(new Function<Vector2, Scalar>(function), comparison)
    {
    }

    public ImplicitScalarFunction2D(Function<Vector2, Scalar> function, ComparisonOperator comparison, Scalar value)
        : this(function.Subtract(value), comparison)
    {
    }

    public ImplicitScalarFunction2D(Func<Vector2, Scalar> function, ComparisonOperator comparison, Scalar value)
        : this(new Function<Vector2, Scalar>(function), comparison, value)
    {
    }

    public ImplicitScalarFunction2D(Function<Vector2, Scalar> left, ComparisonOperator comparison, Function<Vector2, Scalar> right)
        : this(left.Subtract(right), comparison)
    {
    }

    public ImplicitScalarFunction2D(Func<Vector2, Scalar> left, ComparisonOperator comparison, Func<Vector2, Scalar> right)
        : this(new Function<Vector2, Scalar>(left), comparison, new Function<Vector2, Scalar>(right))
    {
    }

    public ImplicitScalarFunction2D(Func<Scalar, Scalar, Scalar> function)
        : this(v => function(v[0], v[1]))
    {
    }

    public ImplicitScalarFunction2D(Func<Scalar, Scalar, Scalar> function, ComparisonOperator comparison)
        : this(v => function(v[0], v[1]), comparison)
    {
    }

    public ImplicitScalarFunction2D(Func<Scalar, Scalar, Scalar> function, ComparisonOperator comparison, Scalar value)
        : this(v => function(v[0], v[1]), comparison, value)
    {
    }

    public ImplicitScalarFunction2D(Func<Scalar, Scalar, Scalar> left, ComparisonOperator comparison, Func<Scalar, Scalar, Scalar> right)
        : this(v => left(v[0], v[1]), comparison, v => right(v[0], v[1]))
    {
    }

    public virtual bool Evaluate(Scalar x0, Scalar x1) => Evaluate(x0, x1, Scalar.ComputationalEpsilon);

    public virtual bool Evaluate(Scalar x0, Scalar x1, Scalar tolerance) => base.Evaluate(new(x0, x1), tolerance);

    public static ImplicitScalarFunction2D StretchBlend(ImplicitScalarFunction2D first, ImplicitScalarFunction2D second, Scalar blend_factor)
    {
        blend_factor = blend_factor.Clamp();

        return new(xy =>
            (1 - xy.Length.Multiply(blend_factor)).Max(Scalar.Zero).Multiply(first.ExplicitFunction.Evaluate(xy)) +
            xy.Length.Multiply(blend_factor).Min(Scalar.One).Multiply(second.ExplicitFunction.Evaluate(xy)),
            Combine(first.ComparisonOperator, second.ComparisonOperator)
        );
    }

    public ImplicitScalarFunction2D Negate() => new(v => ExplicitFunction.Evaluate(-v), ComparisonOperator);

    public ImplicitScalarFunction2D Shift(Vector2 offset) => new(v => ExplicitFunction.Evaluate(v - offset), ComparisonOperator);

    public ImplicitScalarFunction2D Scale(Scalar factor) => new(v => ExplicitFunction.Evaluate(v / factor), ComparisonOperator);

    public static ImplicitScalarFunction2D operator +(ImplicitScalarFunction2D function) => function;

    public static ImplicitScalarFunction2D operator -(ImplicitScalarFunction2D function) => function.Negate();

    public static ImplicitScalarFunction2D operator +(Vector2 offset, ImplicitScalarFunction2D function) => function.Shift(offset);

    public static ImplicitScalarFunction2D operator +(ImplicitScalarFunction2D function, Vector2 offset) => function.Shift(offset);

    public static ImplicitScalarFunction2D operator -(ImplicitScalarFunction2D function, Vector2 offset) => function.Shift(-offset);

    public static ImplicitScalarFunction2D operator *(Scalar scale, ImplicitScalarFunction2D function) => function.Scale(scale);

    public static ImplicitScalarFunction2D operator *(ImplicitScalarFunction2D function, Scalar scale) => function.Scale(scale);

    public static ImplicitScalarFunction2D operator /(ImplicitScalarFunction2D function, Scalar scale) => function.Scale(scale.MultiplicativeInverse);
}

public partial class ImplicitScalarFunction3D
    : ImplicitFunction<Vector3>
{
    public bool this[Scalar x0, Scalar x1, Scalar x2] => Evaluate(x0, x1, x2);

    public bool this[Scalar x0, Scalar x1, Scalar x2, Scalar tolerance] => Evaluate(x0, x1, x2, tolerance);


    public ImplicitScalarFunction3D(ImplicitFunction<Vector3> function)
        : this(function.ExplicitFunction, function.ComparisonOperator)
    {
    }

    public ImplicitScalarFunction3D(Function<Vector3, Scalar> function)
        : this(function, ComparisonOperator.EqualTo)
    {
    }

    public ImplicitScalarFunction3D(Func<Vector3, Scalar> function)
        : this(new Function<Vector3, Scalar>(function))
    {
    }

    public ImplicitScalarFunction3D(Function<Vector3, Scalar> function, ComparisonOperator comparison)
        : base(function, comparison)
    {
    }

    public ImplicitScalarFunction3D(Func<Vector3, Scalar> function, ComparisonOperator comparison)
        : this(new Function<Vector3, Scalar>(function), comparison)
    {
    }

    public ImplicitScalarFunction3D(Function<Vector3, Scalar> function, ComparisonOperator comparison, Scalar value)
        : this(function.Subtract(value), comparison)
    {
    }

    public ImplicitScalarFunction3D(Func<Vector3, Scalar> function, ComparisonOperator comparison, Scalar value)
        : this(new Function<Vector3, Scalar>(function), comparison, value)
    {
    }

    public ImplicitScalarFunction3D(Function<Vector3, Scalar> left, ComparisonOperator comparison, Function<Vector3, Scalar> right)
        : this(left.Subtract(right), comparison)
    {
    }

    public ImplicitScalarFunction3D(Func<Vector3, Scalar> left, ComparisonOperator comparison, Func<Vector3, Scalar> right)
        : this(new Function<Vector3, Scalar>(left), comparison, new Function<Vector3, Scalar>(right))
    {
    }

    public ImplicitScalarFunction3D(Func<Scalar, Scalar, Scalar, Scalar> function)
        : this(v => function(v[0], v[1], v[2]))
    {
    }

    public ImplicitScalarFunction3D(Func<Scalar, Scalar, Scalar, Scalar> function, ComparisonOperator comparison)
        : this(v => function(v[0], v[1], v[2]), comparison)
    {
    }

    public ImplicitScalarFunction3D(Func<Scalar, Scalar, Scalar, Scalar> function, ComparisonOperator comparison, Scalar value)
        : this(v => function(v[0], v[1], v[2]), comparison, value)
    {
    }

    public ImplicitScalarFunction3D(Func<Scalar, Scalar, Scalar, Scalar> left, ComparisonOperator comparison, Func<Scalar, Scalar, Scalar, Scalar> right)
        : this(v => left(v[0], v[1], v[2]), comparison, v => right(v[0], v[1], v[2]))
    {
    }

    public virtual bool Evaluate(Scalar x0, Scalar x1, Scalar x2) => Evaluate(x0, x1, x2, Scalar.ComputationalEpsilon);

    public virtual bool Evaluate(Scalar x0, Scalar x1, Scalar x2, Scalar tolerance) => base.Evaluate(new(x0, x1, x2), tolerance);

    public static ImplicitScalarFunction3D StretchBlend(ImplicitScalarFunction3D first, ImplicitScalarFunction3D second, Scalar blend_factor)
    {
        blend_factor = blend_factor.Clamp();

        return new(xy =>
            (1 - xy.Length.Multiply(blend_factor)).Max(Scalar.Zero).Multiply(first.ExplicitFunction.Evaluate(xy)) +
            xy.Length.Multiply(blend_factor).Min(Scalar.One).Multiply(second.ExplicitFunction.Evaluate(xy)),
            Combine(first.ComparisonOperator, second.ComparisonOperator)
        );
    }

    public ImplicitScalarFunction3D Negate() => new(v => ExplicitFunction.Evaluate(-v), ComparisonOperator);

    public ImplicitScalarFunction3D Shift(Vector3 offset) => new(v => ExplicitFunction.Evaluate(v - offset), ComparisonOperator);

    public ImplicitScalarFunction3D Scale(Scalar factor) => new(v => ExplicitFunction.Evaluate(v / factor), ComparisonOperator);

    public static ImplicitScalarFunction3D operator +(ImplicitScalarFunction3D function) => function;

    public static ImplicitScalarFunction3D operator -(ImplicitScalarFunction3D function) => function.Negate();

    public static ImplicitScalarFunction3D operator +(Vector3 offset, ImplicitScalarFunction3D function) => function.Shift(offset);

    public static ImplicitScalarFunction3D operator +(ImplicitScalarFunction3D function, Vector3 offset) => function.Shift(offset);

    public static ImplicitScalarFunction3D operator -(ImplicitScalarFunction3D function, Vector3 offset) => function.Shift(-offset);

    public static ImplicitScalarFunction3D operator *(Scalar scale, ImplicitScalarFunction3D function) => function.Scale(scale);

    public static ImplicitScalarFunction3D operator *(ImplicitScalarFunction3D function, Scalar scale) => function.Scale(scale);

    public static ImplicitScalarFunction3D operator /(ImplicitScalarFunction3D function, Scalar scale) => function.Scale(scale.MultiplicativeInverse);
}
